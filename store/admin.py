from django.contrib import admin, messages
from django.db.models import Count
from .models import Collection, Product, Customer, Order, OrderItem
from django.utils.html import format_html, urlencode
from django.urls import reverse


# Custom Filter for Inventory
class InventoryFilter(admin.SimpleListFilter): # custom filter for inventory
    title = 'inventory' # display title for the filter
    parameter_name = 'inventory' # parameter name for the filter in the URL
    
    def lookups(self, request, model_admin): # this method returns a list of tuples. each tuple contains a value and a display name for the filter option.
        return [
            ('<10', 'Low') # value is '<10' and display name is 'Low'
        ]
    
    def queryset(self, request, queryset): # this method filters the queryset based on the selected filter option.
        if self.value() == '<10': # if the selected filter option is 'Low'
            return queryset.filter(inventory__lt=10) # filter the queryset to include only products with inventory less than 10
        return queryset # if no filter option is selected, return the original queryset


# Register your models here.
# admin.site.register(Product) # simple way to register a model in the admin site. to edit the admin interface, we need to create a ModelAdmin class.
@admin.register(Collection)
class CollectionAdmin(admin.ModelAdmin):
    list_display = ['title', 'product_count'] # fields to display in the admin list view
    search_fields = ['title'] # fields to search in the admin list view

    @admin.display(ordering='product_count') # this decorator is used to customize the display of the method in the admin list view. ordering parameter is used to specify the field to order by when the column header is clicked.
    def product_count(self, collection): # custom method to display the product count. it takes the collection object as a parameter.
        url = (
            reverse('admin:store_product_changelist') # this is the name of the url pattern for the product changelist view in the admin site. it is generated by django automatically. the format is 'admin:app_label_modelname_changelist'.
            + "?"
            + urlencode({
                'collection__id': str(collection.id) # this is the filter parameter to filter the products by collection id. it is in the format 'fieldname__lookup_type'. here, we are using the foreign key field 'collection' and the lookup type 'id' to filter the products by collection id.
            })
        )
        return format_html('<a href="{}">{}</a>', url, collection.product_count)
        # return collection.product_count # product_set is the reverse relationship of the ForeignKey in the Product model. it is automatically created by django. it is a queryset of all the products related to the collection.

    def get_queryset(self, request):
        return super().get_queryset(request).annotate(product_count=Count('product')) # annotate is used to add a new field to the queryset. here we are adding a new field 'product_count' which is the count of the related products. this will optimize the query and reduce the number of queries to the database.

 
# we can also customize the admin interface by creating a ModelAdmin class and registering it with the model.
@admin.register(Product) # this is a decorator that does the same thing as admin.site.register(Product, ProductAdmin). it is just a cleaner way to do it.
class ProductAdmin(admin.ModelAdmin):
    # inlines = [TagInline] # to display the related tags of a product in the product detail view.
    autocomplete_fields = ['collection'] # this will add a search box to the collection field in the admin form view. it is useful when there are a lot of collections.
    prepopulated_fields = {'slug': ['title']} # this will automatically populate the slug field based on the title field. it is a dictionary where the key is the field to be populated and the value is a list of fields to use for populating the key field.
    # fields = ['title', 'slug'] # fields to display in the admin form view. by default, all fields are displayed.
    # exclude = ['promotions'] # fields to exclude from the admin form view.
    # readonly_fields = ['title'] # fields to make read-only in the admin form view.
    actions = ['clear_inventory'] # custom actions to perform on the selected items in the admin list view
    list_display = ['title', 'unit_price', 'inventory', 'inventory_status', 'collection', 'collection_title'] # here, inventory_status is a custom method defined below. it is not a field in the model. it calls the method and displays the result in the admin list view. here collection is a foreign key field, django automatically displays the related object's __str__ method.
    list_filter = ['collection'] # fields to filter in the admin list view
    list_editable = ['unit_price'] # fields to edit in the admin list view
    list_per_page = 10 # number of items to display per page in the admin list view
    list_select_related = ['collection'] # to optimize the query and reduce the number of queries to the database. it will use a SQL join to fetch the related objects in a single query instead of multiple queries.
    list_filter = ['collection', 'last_update', InventoryFilter] # fields to filter in the admin list view. last_update is a DateTimeField, django will automatically create a date hierarchy filter for it. here InventoryFilter is a custom filter defined above.
    search_fields = ['title']

    @admin.display(ordering='inventory') # this decorator is used to customize the display of the method in the admin list view. ordering parameter is used to specify the field to order by when the column header is clicked.
    def inventory_status(self, product): # custom method to display inventory status. it takes the product object as a parameter.
        if product.inventory < 10:
            return 'Low'
        return 'OK'
    

    # custom action to clear inventory
    @admin.action(description='Clear inventory') # this decorator is used to customize the display of the action in the admin list view. description parameter is used to specify the name of the action.
    def clear_inventory(self, request, queryset): # custom action to clear inventory. it takes the request and queryset as parameters.
        updated_count = queryset.update(inventory=0) # update the inventory of the selected products to 0. this will return the number of rows updated.
        self.message_user(request, f'{updated_count} products were successfully updated.', messages.SUCCESS) # display a message to the user after the action is performed.
    

    def collection_title(self, product): # custom method to display the collection title. it takes the product object as a parameter.
        return product.collection.title

# Note: ModelAdmin vs admin.site.register:
# ModelAdmin is a class that defines the admin interface for a model. it is used to customize the admin interface.
# admin.site.register is a function that registers a model with the admin site. it is used to make a model available in the admin site.



@admin.register(Customer)
class CustomerAdmin(admin.ModelAdmin):
    list_display = ['first_name', 'last_name', 'membership', 'orders'] # here, orders is a custom method defined below. it is not a field in the model. it calls the method and displays the result in the admin list view.
    list_editable = ['membership']
    list_per_page = 10
    search_fields = ['first_name__istartswith', 'last_name__istartswith'] # fields to search in the admin list view. istartswith is a case-insensitive search that matches the beginning of the field. this __isstartswith is a field lookup. other lookups are: exact, iexact, contains, icontains, regex, iregex, gt, gte, lt, lte, startswith, endswith, range, year, month, day, isnull, search, etc.
    ordering = ['first_name', 'last_name'] # ordering in ModelAdmin class is used to define the ordering for the model in the admin site only. it will not affect the ordering in the shell.
# Note: editing in admin.py => ModelAdmin class is for customizing the admin interface,
# while editing in models.py => Meta class is for configuring model behavior (like ordering, verbose_name, etc.)

    @admin.display(ordering='orders') # this decorator is used to customize the display of the method in the admin list view. ordering parameter is used to specify the field to order by when the column header is clicked.
    def orders(self, customer):
        url = (
            reverse('admin:store_order_changelist') # this is the name of the url pattern for the order changelist view in the admin site. it is generated by django automatically. the format is 'admin:app_label_modelname_changelist'.
            + "?"
            + urlencode({
                'customer__id': str(customer.id) # this is the filter parameter to filter the orders by customer id. it is in the format 'fieldname__lookup_type'. here, we are using the foreign key field 'customer' and the lookup type 'id' to filter the orders by customer id.
            })
        )
        return format_html('<a href="{}">{}</a>', url, customer.orders)
    
    def get_queryset(self, request):
        return super().get_queryset(request).annotate(orders=Count('order')) # annotate is used to add a new field to the queryset. here we are adding a new field 'orders' which is the count of the related orders. this will optimize the query and reduce the number of queries to the database.


# Inline model for OrderItem
class OrderItemInline(admin.TabularInline): # this is used to display the related items of an order in the order detail view. it is a tabular inline view.
    autocomplete_fields = ['product'] # this will add a search box to the product field in the inline form view. it is useful when there are a lot of products.
    model = OrderItem # the model to be displayed in the inline view. here, OrderItem is the model that has a foreign key to the Order model. it is a reverse relationship.
    extra = 1 # number of extra forms to display in the inline view. here, we are displaying 1 extra form.
    min_num = 1 # minimum number of forms to display in the inline view. here, we are setting it to 1 to ensure that at least one order item is added.


@admin.register(Order)
class OrderAdmin(admin.ModelAdmin):
    autocomplete_fields = ['customer'] # this will add a search box to the customer field in the admin form view. it is useful when there are a lot of customers.
    inlines = [OrderItemInline]
    list_display = ['id', 'placed_at', 'customer_name']
    list_per_page = 10
    list_select_related = ['customer'] # to optimize the query and reduce the number of queries to the database. it will use a SQL join to fetch the related objects in a single query instead of multiple queries.

    # two way to display related object's field in the admin list view:
    # 1. using a custom method (as shown below)
    # 2. in models.py, __str__ method 
    def customer_name(self, order): # custom method to display the customer name. it takes the order object as a parameter.
        return f"{order.customer.first_name} {order.customer.last_name}" # we can access the related object's fields using the foreign key field.